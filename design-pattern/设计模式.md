## 为什么要使用设计模式？
- 根本原因还是软件开发要实现可维护、可扩展，就必须尽量复用代码，并且降低代码的耦合度。

## 设计模式的原则
- 开闭原则  
软件应该对扩展开放，而对修改关闭。  
这里的意思是在增加新功能的时候，能不改代码就尽量不要改，如果只增加代码就完成了新功能，那是最好的。

- 里氏替换原则  
这是一种面向对象的设计原则，即如果我们调用一个父类的方法可以成功，那么替换成子类调用也应该完全可以运行


## 工厂模式
- 将new操作符单独封装起来，不关注内部实现细节。
- 屏蔽内部创建过程，只提供创建的入口（静态方法）。


## 单例模式
- 一个类只有一个唯一的实例，且只能在内部构建。并提供一个可以访问它的全局访问点。
- 屏蔽外部通过构造函数创建（JS本身无法做到，只能通过模块化或者TS做到），自身只提供获取实例的唯一入口（静态方法）。


## 适配器模式
- 解决2个对象间接口不兼容问题，通过适配器将旧接口转换为兼容接口，将由于接口不兼容而不能工作的2个对象可以一起工作。
- 使用者与适配器相关，而不需要关注接口本身。
- 适配器有3个角色：
    - 目标角色（Target）：大陆的电器插头   
    - 源角色（Adaptee）: 港式的电器插头   
    - 适配器角色（Adapter）: 把港式的电器插头转成更小大陆的电器插头，来适配大陆插座

- 缺点：过多的使用适配器，会使得系统非常凌乱，不易整体进行把握


## 观察者模式
- 对象间的一种一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都得到通知并被自动更新。
- 在观察者模式中，主题是通知的发布者（被观察者），它发出通知时并不需要知道谁是它的观察者，可以有任意数目的观察者订阅并接收通知。
- 完美的将观察者和被观察的对象分离开，实现松耦合。

- 与发布订阅模式的区别：
   - 发布订阅模式属于广义上的观察者模式
   - 在发布订阅模式里，发布者并不会直接通知订阅者，换句话说，发布者和订阅者，彼此互不相识。
   - 通过 "第三者"，也就是消息队列里，我们说的经纪人Broker进行信息交流。
   ```
        发布者只需告诉Broker，我要发的消息，topic是AAA；
        
        订阅者只需告诉Broker，我要订阅topic是AAA的消息；
        
        于是，当Broker收到发布者发过来消息，并且topic是AAA时，就会把消息推送给订阅了topic是AAA的订阅者。当然也有可能是订阅者自己过来拉取，看具体实现。
        
        也就是说，发布订阅模式里，发布者和订阅者，不是松耦合，而是【完全解耦】的。
   ```
   
> 观察者模式中观察者和目标直接进行交互
> 而发布订阅模式中统一由【调度中心】进行处理，订阅者和发布者 互不干扰。
> 这样一方面实现了 解耦，还有就是可以实现更细粒度的一些控制。


## 装饰器模式

## 代理模式

## 外观模式



## 迭代器模式

## 状态模式

